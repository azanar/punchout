{"name":"Punchout","tagline":"A pluggable implementation of the Registry pattern in Ruby","body":"[![Gem Version](https://badge.fury.io/rb/punchout.png)](http://badge.fury.io/rb/punchout)\r\n[![Code Climate](https://codeclimate.com/github/azanar/punchout.png)](https://codeclimate.com/github/azanar/punchout)\r\n[![Build Status](https://travis-ci.org/azanar/punchout.png?branch=master)](https://travis-ci.org/azanar/punchout)\r\n[![Dependency Status](https://gemnasium.com/azanar/punchout.png)](https://gemnasium.com/azanar/punchout)\r\n[![Coverage Status](https://coveralls.io/repos/azanar/punchout/badge.png?branch=readme)](https://coveralls.io/r/azanar/punchout?branch=readme)\r\n\r\npunchout\r\n========\r\nPunchout is an implementation of the [Registry pattern](http://martinfowler.com/eaaCatalog/registry.html) that tries to make as few assumptions as possible about what is being registered, and how it wants to be found.\r\n\r\nPunchout relies on the following three components to works its magic:\r\n\r\n* A `Matcher`, which decides if a passed in values 'matches'.\r\n* A `Matchable`, which will stores a value and a `Matcher`, and returns a value on a successful match.\r\n* A `Punchable`, which is an extended module allowing for registration and lookup against `Matchable` objects.\r\n\r\n\r\nMatchers\r\n--------\r\n\r\nSeveral `Matcher` classes are provided, and it is very easy to define your own `Matcher` classes.\r\n\r\nAn example matcher to determine if a particular value is awesome:\r\n\r\n```ruby\r\nclass Awesomeness < Punchout::Matcher\r\n  def matches?(thing)\r\n    thing.respond_to?(:awesome?) && thing.awesome?\r\n  end\r\nend\r\n```\r\n\r\nMatchable\r\n---------\r\n\r\nA `Matchable` defines a relationship between a subclass of `Matcher` and a value to be returned.\r\n\r\nA `Matchable` can be created as follows for testing equality, using the built-in `Punchout::Matcher::Equal` matcher\r\n\r\n```ruby\r\nrequire 'punchout/matcher/equal'\r\n\r\nmatcher = Punchout::Matcher::Equal(42)\r\n\r\nmatchable = Punchout::Matchable.new(matcher, 'meaning of life')\r\n```\r\n\r\nPunchable\r\n---------\r\n\r\nPunchout allows you to declare modules as `Punchable`, \r\n\r\nlike as follows:\r\n\r\n```ruby\r\nrequire 'punchout'\r\n\r\nmodule Things\r\n  extends Punchout::Punchable\r\n  \r\n  #...other code...  \r\nend\r\n```\r\n\r\nThis will make your module `Punchable`, but at this point, there is nothing registered to `punch`.\r\n\r\nWhen you extend something as `Punchable`, this exposes two new public methods: `#add` and `#punch`. \r\n\r\n* `puncher#add` is used to register a `Matchable` object against the Punchable module. \r\n\r\n* `#punch` returns the value attached to the first registered `Matchable` to match against the passed value.\r\n\r\nExample\r\n-------\r\n\r\n```ruby\r\nrequire 'punchout'\r\n\r\nmodule Things\r\n  extends Punchout::Punchable\r\n  \r\n  def self.add(thing)\r\n    puncher.add(thing.name, thing)\r\n  end\r\n  #...other code...  \r\nend\r\n\r\nclass Thing\r\n  def initialize(name)\r\n    @name = name\r\n  end\r\n  \r\n  attr_reader :name\r\nend\r\n\r\nthing1 = Thing.new(\"thing1\")\r\nthing2 = Thing.new(\"thing2\")\r\n\r\nThings.add(thing1)\r\nThings.add(thing2)\r\n\r\nThings.punch(\"thing2\") # returns thing2\r\nThings.punch(\"thing3\") # returns nil\r\n```\r\n\r\nContributors\r\n------------\r\n\r\nSee [Contributing](CONTRIBUTING.md) for details.\r\n\r\nLicense\r\n-------\r\n\r\nSee [License](LICENSE) for details.\r\n\r\nCopyright\r\n-------\r\n\r\n&copy;2013 Ed Carrel and Pocket Change\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}